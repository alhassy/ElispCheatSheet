# f7 preview changes
# (local-set-key (kbd "<f7>") (lambda () (interactive) (async-shell-command (concat "open " (org-latex-export-to-pdf)))))

# f8 commit each change
# f9 push changes

* Header                                                     :ignore:
#+TITLE: Elisp Reference Sheet
# SUBTITLE: Cheat Sheet Template
# DATE: << Winter 2019 >>
# When we don't provide a date, one is provided for us.
#+MACRO: URL https://github.com/alhassy/ElispCheatSheet
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: This document is written by Musa Al-hassy for his learning in the Winter of 2019.
#+STARTUP: hideblocks
#+STARTUP: overview
#+TODO: TODO | spacing
#+OPTIONS: d:nil
#+INCLUDE: CheatSheet/CheatSheetSetup.org

* LaTeX Setup                                                :ignore:
# Can be obtained from: https://github.com/alhassy/MyUnicodeSymbols
#
#+LATEX_HEADER: \usepackage{/Users/musa/MyUnicodeSymbols/MyUnicodeSymbols}

#+NAME: parallel enviro
#+BEGIN_EXPORT latex 
% \setlength{\columnseprule}{2pt}

\renewenvironment{parallel}[1][2] % one argument, whose default value is literal `2`.
 {
  \setlength{\columnseprule}{2pt}
  \begin{minipage}[t]{\linewidth} % width of minipage is 100% times of \linewidth
  \begin{multicols}{#1}  % default is `2`
 }
 {
 \setlength{\columnseprule}{0pt}
  \end{multicols}
  \end{minipage}
 }
#+END_EXPORT

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

* Intro :ignore:
/Everything is a list!/

- To find out more about ~name~ execute ~(describe-symbol 'name)~!
  * After the closing parens invoke ~C-x C-e~ to evaluate.
- To find out more about a key press, execute ~C-h k~ then the key press.
- To find out more about the current mode you're in, execute ~C-h m~ or
  ~describe-mode~. Essentially a comprehensive yet terse reference is provided.
:Examples:
(describe-symbol 'just-one-space)
(describe-symbol 'eldoc-mode)
(describe-symbol 'describe-symbol)
:End:

* Functions

+ Function invocation: ~(f x₀ x₁ … xₙ)~. E.g., ~(+ 3 4)~ or ~(message "hello")~.
  - After the closing parens invoke ~C-x C-e~ to execute them.
  - /Warning!/ Arguments are evaluated *before* the function is executed.
  - Only prefix invocations means we can use ~-,+,*~ in /names/
    since ~(f+*- a b)~ is parsed as applying function ~f+*-~ to arguments ~a, b~.
    # Having infix notation, as in “a - b”, is what renders names “a-b”
    # from being parsed correctly. Lisp does not make use of infix names,
    # so this is a non-issue. Interestingly Agda allows +-* in names and infix!

    E.g., ~(1+ 42) → 43~ using function /named/ ~1+~ --the ‘successor function’.

+ Function definition:
  #+BEGIN_SRC elisp
  ;; “de”fine “fun”ctions
  (defun my-fun (arg₀ arg₁ … argₖ)        ;; header, signature
    "This functions performs task …"       ;; documentation, optional
    …sequence of instructions to perform…  ;; body
  )
  #+END_SRC

  - The return value of the function is the result of the last expression executed. 
  - The documentation string may indicate the return type, among other things.  

+ Anonymous functions: ~(lambda (arg₀ … argₖ) bodyHere)~.
  #
  #+begin_parallel org
#+BEGIN_SRC elisp
;; make then way later invoke
(setq my-f (lambda (x y) (+ x y)))
(funcall my-f 1 2)
;; (my-func 1 2) ;; invalid!
#+END_SRC
\columnbreak
    #+BEGIN_SRC elisp
;; make and immediately invoke
(funcall (lambda (x y) (+ x y)) 1 2)
 ;; works, but is deprecated
((lambda (x y) (+ x y)) 1 2)
#+END_SRC
#+end_parallel
  
  The last one is invalid since ~(f x0 … xk)~ is only meaningful for functions
  ~f~ formed using ~defun~. More honestly, Elisp has distinct namespaces for functions and variables.

:Deprecated_form:
;; make and immediately invoke
((lambda (x y) (message (format "x, y ≈ %s, %s" x y))) 1 2)

https://www.gnu.org/software/emacs/manual/html_node/elisp/Function-Indirection.html

:End:

:To_investigate_further:
\room
  Indeed, ~(defun f (x₀ … xₖ) body) ≈ (fset 'f (lambda (x₀ … xₖ) body))~.
  - Using ~fset~, with quoted name, does not require using ~funcall~.

   (insert (format "\n %s" (macroexpand '(defun f (xs) body))))
   (defalias (quote f) (function (lambda (xs) body)))
:End:

\room
Functions are first-class values; the function represented by the name /f/ is obtained
  by the call ~#'f~.

  # “lambda” is actually a macro!
  # (macroexpand '(lambda (x) x))
  
  :Try_it_out:
#+BEGIN_SRC emacs-lisp
(defun f (x) x) ;; identify function
(funcall #'f 4)

(defun fmap (h xs) (if xs (cons (funcall h (car xs)) (fmap h (cdr xs))) xs))
(fmap #'f '(1 2 3))
(fmap (lambda (x) (* 2 x)) '(1 2 3))
#+END_SRC
:End:

#+latex: \vspace{-1em}
#+BEGIN_SRC emacs-lisp
;; Recursion with the ‘tri’angle numbers: tri n = sum [0..n].
(defun tri (f n) (if (<= n 0) 0 (+ (funcall f n) (tri f (- n 1)))))
(tri #'identity 100)           ;; ⇒ 5050
(tri (lambda (x) (/ x 2)) 100) ;; ⇒ 2500
#+END_SRC

IO: In general ~interactive~ may take no arguments.
It lets us use ~M-x~ to execute functions;
here, this results in ~n~ being queried to the user.
#+BEGIN_SRC emacs-lisp
(defun double (n) (interactive "n") (message-box (format "%s" (* n 2))))
#+END_SRC

:Old:
+ Recursion:
   ~(defun sum (f n) (if (<= n 0) 0 (+ (funcall f n) (sum f (- n 1)))))~
  - Now ~(sum #'identity 100) → 5050~ and ~(sum (lambda (x) (/ x 2)) 100) → 2500~.

+ IO: ~(defun make-sum (n) (interactive "n") (message-box (format "%s" (sum n))))~

   The ~interactive~ option means the value of ~n~ is queried to the user; e.g.,
enter 100 after executing ~(execute-extended-command "" "make-sum")~ or ~M-x make-sum~.

In general ~interactive~ may take no arguments.
    The benefit is that the function can be executed using ~M-x~,
    and is then referred to as an interactive function.
:End:

We may have positional ~optional~ arguments, or optional but named arguments
---for which position does not matter.
Un-supplied optional arguments are bound to ~nil~.
#
#+begin_parallel org
#+BEGIN_SRC emacs-lisp
(cl-defun f (a &optional b (c 5))
   (format "%s %s %s" a b c))

(f 'a)       ;; ⇒ "a nil 5"
(f 'a 'b)    ;; ⇒ "a b 5"
(f 'a 'b 'c) ;; ⇒ "a b c"
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cl-defun g (a &key (b 'nice) c)
   (format "%s %s %s" a b c))

(g 1 :c 3 :b 2) ;; ⇒ "1 2 3"
(g 1 :c 3)      ;; ⇒ "1 nice 3"
#+END_SRC
#+end_parallel

Keywords begin with a colon, ~:k~ is a constant whose value is ~:k~.

* Quotes, Quasi-Quotes, and Unquotes

Quotes: ~'x~ refers to the /name/ rather than the /value/ of ~x~.

  - This is superficially similar to pointers:
    Given ~int *x = …~, ~x~ is the name (address)
    whereas ~*x~ is the value.
  - The quote simply forbids evaluation; it means /take it literally as you see it/
    rather than looking up the definition and evaluating.
    :TryItOut:
    #+BEGIN_SRC elisp
(setq this 'hello)
(setq that this)

;;  this  → hello
;; 'this  → this
;;  that  → hello
;; 'that  → that
#+END_SRC 
    :End:
  - Note: ~'x ≈ (quote x)~.

:Try_it_out:
#+BEGIN_SRC emacs-lisp
'x ≈ (quote x)
(equal 'x (quote x)) ;; true

''x ≠ 'x
(equal 'x ''x) ;; false
#+END_SRC
:End:

  \room
Akin to English, quoting a word refers to the word and not what it denotes.

This lets us treat /code/ as /data/! E.g., ~'(+ 1 2)~ evaluates to ~(+ 1 2)~, a function call,
    not the value ~3~! Another example, ~*~ is code but ~'*~
    is data, and so ~(funcall '* 2 4)~ yields 8.

\room

/Elisp expressions are either atoms or function application --nothing else!/

‘Atoms’ are the simplest objects in Elisp: They evaluate to themselves; \newline
e.g., ~5, "a", 2.78, 'hello, [1 "two" three]~.
    :lambdas_are_not_literals:    
     lambda's form function literals in that, e.g.,
    ~(lambda (x) x)~ evaluates to itself.

    Read here: https://nullprogram.com/blog/2018/02/22/
    :End:

  # Reddit/skeeto: There are lots of types in Emacs Lisp that are "atoms" but not actually atomic: vectors, records, hash tables, etc.   

  
\room

An English sentence is a list of words; if we want to make a sentence where some of
the words are parameters, then we use a quasi-quote --it's like a quote, but allows
us to evaluate data if we prefix it with a comma. It's usually the case that the
quasi-quoted sentence happens to be a function call! In which case, we use ~eval~
which executes code that is in data form; i.e., is quoted.

\room
Macros are essentially functions that return sentences, lists, which may happen to
contain code.

#+begin_parallel org
#+BEGIN_SRC emacs-lisp
;; Quotes / sentences / data 
'(I am a sentence)
'(+ 1 (+ 1 1))

;; Executing data as code
(eval '(+ 1 (+ 1 1)))  ;; ⇒ 3
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq name "Jasim")

;; Quasi-quotes: Sentences with a
;; computation, code, in them.
`(Hello ,name and welcome)
`(+ 1 ,(+ 1 1))  ;; ⇒ '(+ 1 2)          
#+END_SRC
#+end_parallel

As the final example shows, Lisp treats data and code interchangeably.
A language that uses the same structure to store data and code is called ‘homoiconic’.

* Reads

#+latex: {\color{white}.}\vspace{-1em}
+ [[http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs-v2-Large.png][How to Learn Emacs: A Hand-drawn One-pager for Beginners / A visual tutorial]]
+ [[https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html][Learn Emacs Lisp in 15 minutes]] --- https://learnxinyminutes.com/
+ [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html#Top][An Introduction to Programming in Emacs Lisp]] @@latex: \hfill  ---also @@ [[http://landoflisp.com/][Land of Lisp]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top][GNU Emacs Lisp Reference Manual]] 
  
* Variables
# (describe-symbol 'make-variable-buffer-local)

+ Global Variables, Create & Update: ~(setq name value)~.
  - Generally: ~(setq name₀ value₀ ⋯ nameₖ valueₖ)~.
  
  Use ~devfar~ for global variables since it
  permits a documentation string --but updates must be performed with ~setq~.
  E.g., ~(defvar my-x 14 "my cool thing")~.

  :TryItOut:
(defvar my-x 14 "my cool thing")

my-x ;; ⇒ 14

(defvar my-x 16 "my cool thing")

my-x ;; ⇒ 14 still

(setq my-x 16)
my-x ;; ⇒ now 16

(describe-symbol 'my-x)


  :End:

  | ~(setq x y) ≈ (set (quote x) y)~ |
  
  Variables are assigned with ~set~,
  which takes a quoted identifier, so that it's not evaluated,
  and a value to associate to that variable. “set quoted”, ~setq~,
  avoids the hassle of quoting the name.
  More generally, ~(set sym v)~ assigns the /value of/ ~sym~ to have the value ~v~.

  # Of course functions evaluate their arguments, so ~setq~ couldn't possibly be a function.
  # It's an uber-function, called a ‘macro’, that doesn't evaluate its arguments before executing.

+ Local Scope: ~(let ((name₀ val₀) … (nameₖ valₖ)) bodyBlock)~.
  - ~let*~ permits later bindings to refer to earlier ones.
  - The simpler ~let~ indicates to the reader that there are no dependencies between the variables.
  - let ≈ parallel; let* ≈ sequential.
  - Local functions declared with ~flet~ and ~flet*~; e.g.,
    ~(flet ((go (x) (+ 2 x))) (go 3))~.
    
+ Any sequence of symbols is a valid identifier, including ~x, x-y/z, --<<==>>--~
  and even ~∀∃~. Elisp names are case sensitive.
  :Try_it_out:
#+BEGIN_SRC emacs-lisp
(setq ∀∃ 23)
(message (format "%s" ∀∃))

(setq --<<==>>-- 23)
(message (format "%s" --<<==>>--))

(eq '∀∃ '--<<==>>--) ;; false 
(eq '∀∃ '∀∃)         ;; true

;; Elisp names are case sensitive 
(eq 'foobar 'fOoBaR) ;; ⇒ false
#+END_SRC
:End:
  
+ Elisp is dynamically scoped: The caller's stack is accessible by default!
  #+BEGIN_SRC emacs-lisp
(defun woah () 
  "If any caller has a local ‘work’, they're in for a nasty bug
   from me! Moreover, they better have ‘a’ defined in scope!"
  (setq work (* a 111))) ;; Benefit: Variable-based scoped configuration.

(defun add-one (x)
  "Just adding one to input, innocently calling library method ‘woah’."
  (let ((work (+ 1 x)) (a 6))
    (woah) ;; May change ‘work’ or access ‘a’!
    work
  )
)

;; (add-one 2) ⇒ 666
#+END_SRC

:Todo_mention_lexcial_binding:
https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html
:End:

* spacing COMMENT newpage                                                    :ignore:
\newpage
* spacing COMMENT newpage                                                    :ignore:
\newpage
* Lists and List-Like Structures

+ Produce a syntactic, un-evaluated list, we use the single quote:
  ~'(1 2 3)~.

+ Construction: ~(cons 'x₀ '(x₁ … xₖ)) → (x₀ x₁ … xₖ)~.

+ Head, or /contents of the address part of the register/:
   ~(car '(x₀ x₁ … xₖ)) → x₀~.

+ Tail, or /contents of the decrement part of the register/:
   ~(cdr '(x₀ x₁ … xₖ)) → (x₁ … xₖ)~.

# + Deletion: ~(delete e xs)~ yields ~xs~ with all instance of ~e~ removed.
#  - E.g., ~(delete 1 '(2 1 3 4 1)) → '(2 3 4)~.
#
# (describe-symbol 'remove-if-not) ;; “filter” ;-)

E.g., ~(cons 1 (cons "a" (cons 'nice nil))) ≈ (list 1 "a" 'nice) ≈ '(1 "a" nice)~.

\room
Since variables refer to literals and functions have lambdas as literals, we 
can produce forms that take functions as arguments. E.g., the standard ~mapcar~
may be construed:
#+BEGIN_SRC emacs-lisp
(defun my-mapcar (f xs)
  (if (null xs) xs
   (cons (funcall f (car xs)) (my-mapcar f (cdr xs)))))

(my-mapcar (lambda (x) (* 2 x)) '(0 1 2 3 4 5)) ;; ⇒ (0 2 4 6 8 10)
(my-mapcar 'upcase '("a" "b" "cat")) ;; ⇒ ("A" "B" "CAT")
#+END_SRC

Pairs: ~(x . y) ≈ (cons x y)~.

  An association list, or alist, is a list formed of such pairs.
  They're useful for any changeable collection of key-value pairs.
  The ~assoc~ function takes a key and an alist and returns the first pair
  having that key. In the end, alists are just lists.

  :Try_it_out:  
#+BEGIN_SRC emacs-lisp
(setq drinks '( (jasim . coffee) (mary . tea) (jasim . chai) ))

(assoc 'mary drinks) ;; ⇒ (mary . tea)
(assoc 'jasim drinks) ;; ⇒ (jasim . coffee)

(push '(mary . cola) drinks)
(assoc 'mary drinks) ;; ⇒ (mary . cola)
#+END_SRC
:End:

\room  
(Rose) Trees in lisp are easily formed as lists of lists where each inner
   list is of length 2:
   The first symbol is the parent node and the second is the list of children.

\room   
Lists are formed by chains of cons cells, so getting and setting are very slow;
likewise for alists. If performance is desired, one uses arrays and hash tables,
respectively, instead. In particular, the performance of arrays and hash tables always
requires a constant amount of time whereas the performance of lists and alists grows in
proportion with their lengths.

However, the size of an array is fixed ---it cannot change and thus grow--- and hash
tables have a lookup cost as well as issues with "hash collisions". Their use is worth
it for large amounts of data, otherwise lists are the way to go.

\room
An [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Arrays.html][array]] is created like a list but using [only square brackets] with getter ~(aref arr index)~.

A hash table is created with ~(make-hash-table)~ with getter ~(gethash key table)~.

:Try_it_out:
#+BEGIN_SRC emacs-lisp
(setq x [0 1 2 nice])
(aref x 3)
(aset x 0 'woah)

(setq drinks (make-hash-table))
(setf (gethash 'mary drinks) 'tea)
(setf (gethash 'mary drinks) 'chai)
(gethash 'mary drinks) ;; ⇒ 'chai
#+END_SRC
:End:

\room
What if you look up a key and get ~nil~, is there no value for that key or is the value
~nil~? ~gethash~ takes a final, optional, argument which is the value to return when the
key is not found; it is ~nil~ by default.

* Generic Setters
  
Since everything is a list in lisp, if ~G~ is a way to get a value from variable ~x~, then ~(setf G e)~ updates ~x~ so that the location ~G~ now refers to element ~e~.
Hence, once you have a getter ~G~ you freely obtain a setter ~(setf G ⋯)~.
# G may be arbitrary complex.

# E.g., ~nth~ is a way to get a value from a list; ~(setf (nth 2 x) 'nice)~ changes the list ~x~ at index ~2~ to have value ~'nice~.

#+BEGIN_SRC emacs-lisp
;; Element update
(setq x '(0 1 2 3))    ;; x ⇒ '(0 1 2     3)
(setf (nth 2 x) 'nice) ;; x ⇒ '(0 1 'nice 3)

;; Circular list
(setq y '(a b c))   ;; y ⇒ '(a b c)
(setf (cdddr y) y)  ;; y ⇒ '(a b c a b . #2)
;; “#2” means repeat from index 2.
(nth 99 y) ;; ⇒ a
#+END_SRC
  
* spacing newpage                                                    :ignore:
\newpage
* Records

If we want to keep a list of related properties in a list, then we have to remember
which position keeps track of which item and may write helper functions to keep track
of this. Instead we could use a structure.
:More:
A Lisp "Structure, record, object" represents objects with properties as in OOP.
Make a structure like this: (defstruct X (f1 d1) (f2 d2) ... (fn dn)), this creates a record type named X with slots/properties/fields fi having defaults di or nil if di is absent in which case we simply write fi rather than (fi di), moreover it gives the generic constructor (make-X :f1 val1 :f2 val2 ... :fn valn) where any of the fi is optional and assigned nil by default; projection functions X.fi are also provided automatically.
Printing and reading symmetry works as expected with structures and updates happen with setf as expected.
:End:

#+BEGIN_SRC elisp
(defstruct X "Record with fields/slots fᵢ having defaults dᵢ" 
  (f₀ d₀) ⋯ (fₖ dₖ))

;; Automatic constructor is “make-X” with keyword parameters for 
;; initialising any subset of the fields!
;; Hence (expt 2 (1+ k)) kinds of possible constructor combinations!
(make-X :f₀ val₀ :f₁ val₁ ⋯ :fₖ valₖ) ;; Any, or all, fᵢ may be omitted

;; Automatic runtime predicate for the new type.
(X-p (make-X)) ;; ⇒ true
(X-p 'nope)    ;; ⇒ nil

;; Field accessors “X-fᵢ” take an X record and yield its value.

;; Field update: (setf (X-fᵢ x) valᵢ)

(defstruct book
  title  (year  0))

(setq ladm (make-book :title "Logical Approach to Discrete Math" :year 1993))
(book-title ladm) ;; ⇒ "Logical Approach to Discrete Math"
(setf (book-title ladm) "LADM")
(book-title ladm) ;; ⇒ "LADM"
#+END_SRC

Advanced OOP constructs can be found within the CLOS, Common Lisp Object System;
which is also used as a research tool for studying OOP ideas.

* Block of Code

Use the ~progn~ function to treat multiple expressions as a single expression. E.g.,
#+BEGIN_SRC elisp
(progn
  (message "hello")
  (setq x  (if (< 2 3) 'two-less-than-3))
  (sleep-for 0 500)
  (message (format "%s" x))
  (sleep-for 0 500)
  23    ;; Explicit return value
)
#+END_SRC
This' like curly-braces in C or Java. The difference is that the last expression is considered
the ‘return value’ of the block.

Herein, a ‘block’ is a number of sequential expressions which needn't be wrapped with a ~progn~ form.

+ Lazy conjunction and disjunction:
  - Perform multiple statements but stop when any of them fails, returns ~nil~: ~(and s₀ s₁ … sₖ)~.
    * Maybe monad!
  - Perform multiple statements until one of them succeeds, returns non-~nil~: ~(or s₀ s₁ … sₖ)~.
  
  We can coerce a statement ~sᵢ~ to returning non-~nil~ as so: (~progn sᵢ t)~.
  Likewise, coerce failure by ~(progn sᵢ nil)~.
  
:TryItOut:
#+BEGIN_SRC emacs-lisp
(and 
  (message "hello")
  (progn (sleep-for 0 500) t)
  (message "world")
  (progn (sleep-for 0 500) t)  
  nil
  (message "bye")
)

(or
  (message "hello")
  (progn (sleep-for 0 500) t)
  (message "world")
  (progn (sleep-for 0 500) t)  
  nil
  (message "bye")
)

(catch 'failure
  (cond (message "hello")
    (progn (sleep-for 0 500) t)
    (message "world")
    (progn (sleep-for 0 500) t)  
    nil
    (throw 'failure 99)
    (message "bye")  
  ) 
)
#+END_SRC

:End:

+ Jumps, Control-flow transfer: Perform multiple statements and decide when and where you would like to stop. This' akin to C's ~goto~'s; declare a label with ~catch~ and goto it with ~throw~.
  - ~(catch 'my-jump bodyBlock)~ where the body may contain ~(throw 'my-jump returnValue)~;
  the value of the catch/throw is then ~returnValue~.
  - Useful for when the ~bodyBlock~ is, say, a loop.
    Then we may have multiple ~catch~'s with different labels according to the nesting of loops.
    * Possibly informatively named throw symbol is ~'break~.
  - Using name ~'continue~ for the throw symbol and having such a catch/throw as /the body of a loop/
    gives the impression of continue-statements from Java.
  - Using name ~'return~ for the throw symbol and having such a catch/throw as the body of a function
    definition gives the impression of, possibly multiple, return-statements from Java
    --as well as ‘early exits’.
  - Simple law: ~(catch 'it s₀ s₁ … sₖ (throw 'it r) sₖ₊₁ ⋯ sₖ₊ₙ) ≈ (progn s₀ s₁ ⋯ sₖ r)~.
    * Provided the ~sᵢ~ are simple function application forms.

+ ~and, or~ can be thought of as instance of catch/throw, whence they are control flow
  first and Boolean operations second.
    #+BEGIN_SRC emacs-lisp
  (and s₀ ⋯ sₙ e)  ⇒  when all xᵢ are true, do e
  (or  s₀ ⋯ sₙ e)  ⇒  when no xᵢ is true, do e
#+END_SRC

* Conditionals

+ Booleans: ~nil~, the empty list ~()~, is considered /false/, all else
  is /true/. 
  - Note: ~nil ≈ () ≈ '() ≈ 'nil~.
  - (Deep structural) equality: ~(equal x y)~.
  - Comparisons: As expected; e.g., ~(<= x y)~ denotes /x ≤ y/.

+ ~(if condition thenExpr optionalElseBlock)~
  - Note: ~(if x y) ≈ (if x y nil)~; \newline better: ~(when c thenBlock) ≈ (if c (progn thenBlock))~.
  - Note the else-clause is a ‘block’: Everything after the then-clause is considered to be part of it.  
  - ~(if xs ⋯)~ means “if xs is nonempty then ⋯” is akin to C style idioms on
    linked lists.
    
#
#+begin_parallel org  
#+BEGIN_SRC emacs-lisp
(cond
  (test₀
    actionBlock₀)
  (test₁
    actionBlock₁)
  …
  (t                    ;; optional
    defaultActionBlock))
#+END_SRC
  \columnbreak
   #+BEGIN_SRC emacs-lisp
;; pattern matching on any type
(defun go (x)
  (pcase x
    ('bob 1972)
    (`(,a ,_ ,c) (+ a c))
    (otherwise "Shucks!")))

(go 'bob)     ;; ⇒ 1972
(go '(1 2 3)) ;; ⇒ 4
(go 'hallo)   ;; "Shucks!"
#+END_SRC
#+end_parallel

Avoid nested if-then-else clauses by using a ~cond~ statement --a (lazy) generalisation
of switch statements: It sequentially evaluates the expressions ~testᵢ~ and
performs only the action of the first true test; yielding ~nil~ when no tests are true.
Or use [[http://www.wilfred.me.uk/blog/2017/03/19/pattern-matching-in-emacs-lisp/][pattern matching]]; which even allows predicates in the case position ---~C-h o~ ;-)
   
:Try_it_out:   
#+BEGIN_SRC emacs-lisp
(cond
  (t (message "first"))
  ((/ 2 0) (message "crash"))
)
#+END_SRC
:End:

\room
Hint: If you write a predicate, think of what else you can return besides ~t~; such as
a witness to why you're returning truth --all non-nil values denote true after all.
E.g., ~(member e xs)~ returns the sublist of ~xs~ that begins with ~e~.
# Return more than just the truth!

:Try_it_out:
#+BEGIN_SRC emacs-lisp
(member 1 '(2 1 3 5))
#+END_SRC
:End:

* spacing COMMENT vfill                                                     :ignore:
\vfill


* Loops

Let's sum the first ~100~ numbers in 3 ways.
#
#+begin_parallel org
#+BEGIN_SRC elisp
(let ((n 100) (i 0) (sum 0))
  (while (<= i n)
    (incf sum i) (incf i))
    (message (format "sum: %s" sum)))
#+END_SRC
\columnbreak

| _C_      | _Elisp_      |
| ~x += y~ | ~(incf x y)~ |
| ~x -= y~ | ~(decf x y)~ |

~y~ is optional, and is 1 by default.
#+end_parallel

# dotimes is just a specfic while loop.
# (insert (format "\n\n%s" (macroexpand '(dotimes (x l r) b))))

# Two instances of a while loop:
#+BEGIN_SRC elisp
;; Repeat body n times, where i is current iteration.
(let ((result 0) (n 100))
  (dotimes (i (1+ n) result) (incf result i)))

;; A for-each loop: Iterate through the list [0..100].
(let ((result 0) (mylist (number-sequence 0 100)))
  (dolist (e mylist result) (incf result e)))
#+END_SRC

In both loops, ~result~ is optional and defaults to nil.
It is the return value of the loop expression.
#+latex: \vspace{-1em}
| *Example of Above Constructs* |
#+latex: \vspace{-1em}
#+BEGIN_SRC emacs-lisp
(defun my/cool-function (N D)
  "Sum the numbers 0..N that are not divisible by D"
  (catch 'return
    (when (< N 0) (throw 'return 0)) ;; early exit
    (let ((counter 0) (sum 0))
      (catch 'break
        (while 'true
          (catch 'continue
            (incf counter)
            (cond ((equal counter N)       (throw 'break sum   ))
                   ((zerop (% counter D))  (throw 'continue nil))
                   ('otherwise             (incf sum counter   )) )))))))

(my/cool-function  100 3)  ;; ⇒ 3267
(my/cool-function  100 5)  ;; ⇒ 4000
(my/cool-function -100 7)  ;; ⇒ 0
#+END_SRC

The special [[http://www.gigamonkeys.com/book/loop-for-black-belts.html][loop]] construct provides immensely many options to form
nearly any kind of imperative loop. E.g., Python-style ‘downfrom’ for-loops
and Java do-while loops. I personally prefer functional programming, so wont
look into this much.

* Exception Handling

We can attempt a dangerous clause and catch a possible exceptional case
--below we do not do so via ~nil~-- for which we have an associated handler.
# Which handles how to recover from such exceptional circumstances.
#+BEGIN_SRC elisp
(condition-case nil attemptClause (error recoveryBody))

  (ignore-errors attemptBody) 
≈ (condition-case nil (progn attemptBody) (error nil))

(ignore-errors (+ 1 "nope")) ;; ⇒ nil
#+END_SRC

* Types & Overloading

Since Lisp is dynamically typed, a variable can have any kind of data, possibly
different kinds if data at different times in running a program.
We can use ~type-of~ to get the type of a given value; suffixing that with ~p~
gives the associated predicate; \newline e.g., ~function ↦ functionp~.
:More:
The following predicates tell us what kind of data a variable
has: ~numberp, arrayp, characterp,~
~consp, functionp, hash-tablep, listp, stringp, and symbolp~.
:End:

:Details:
Using these we can write functions that behave differently according to the types of
their arguments. However this sort of ad hoc polymorphism can be slow and difficult to
maintain when new types need to be considered. Instead, we could create overloaded
methods using the defmethod command: Lisp decides which one to use by considering the
types, hence the types of each declaration need to differ in at least one argument.
:End:

:Try_it_out:
#+BEGIN_SRC emacs-lisp
(type-of 3)        ;; integer
(type-of "3")      ;; string
(type-of 'x)       ;; symbol
(type-of '(x . y)) ;; cons
(type-of nil)      ;; symbol
(type-of '(1 2 3)) ;; cons
(type-of [1 2 3])  ;; vector
#+END_SRC
:End:

#+BEGIN_SRC emacs-lisp
;; Difficult to maintain as more types are added.
(defun sad-add (a b)
  (if (and (numberp a) (numberp b))    
      (+ a b)
      (format "%s + %s" a b))  
)

(sad-add 2 3)       ;; ⇒ 5 
(sad-add 'nice "3") ;; ⇒ "nice + 3"

;; Better: Seperation of concerns.
;;
(cl-defmethod add ((a number) (b number)) (+ a b))      ;; number types 
(cl-defmethod add ((a t) (b t)) (format "%s + %s" a b)) ;; catchall types

(add 2 3)       ;; ⇒ 5 
(add 'nice "3") ;; ⇒ "nice + 3"
#+END_SRC

While list specific functions like list-length and mapcar may be more efficient than
generic functions, which require extra type checking, the generic ones are easier to
remember. The following generic functions work on lists, arrays, and strings:
+ ~find-if~, gets first value satisfying a predicate.
+ ~count~, finds how often an element appears in a sequence
+ ~position~, finds the index of a given element.
+ ~some~, check if any element satisfies a given predicate
+ ~every~, check if every element satisfies the given predicate
+ ~reduce~, takes a binary operation and a sequence and mimics a for-loop.
  Use keyword ~:initial-value~ to specify the starting value, otherwise use head of
  sequence.
+ ~sum~, add all numbers; crash for strings.
+ ~length, subseq, sort~.
:More:
+ ~map~, like ~mapcar~ but works for any sequence with the added ability to transform
  sequences to other types: Its first argument could be ~'list~ even if we operate in a
  string, so that the list is converted after the operation is mapped.
+ ~subseq~, yields subsequence according to given indices.
+ ~sort~, takes an ordering relation and sorts according to it.
:End:

[[https://github.com/magnars/dash.el][dash]] is a modern list library for Emacs that uses Haskell-like names for list operations ;-)
Likewise, [[https://github.com/magnars/s.el][s]] is a useful Emacs string manipulation library.

In-fact, we can [[https://github.com/knupfer/haskell-emacs][write Emacs extensions using Haskell directly]].

* spacing  newpage                                          :ignore:
\newpage
* Macros

  Macros let us add new syntax, like ~let1~ for single lets:
  #
  # Need to have a space before using ‘parallel’.
  #
  #+begin_parallel org
     #+BEGIN_SRC emacs-lisp
 ;; Noisy parens!
 (let ((x "5")) (message x))

 ;; Better.
 (let1 x "5" (message x))

 ;; How?
 (defmacro let1 (var val &rest body)
  `(let ((,var ,val)) ,@body))

 ;; What does it look like?
 (macroexpand
   '(let1 x "5" (message x)))
 ;; ⇒ (let ((x 5)) (message x))
 #+END_SRC
   \columnbreak   
     #+BEGIN_SRC emacs-lisp
 ;; No progn; (first x y z) ≈ x    
 (defmacro first (&rest body)
  (car `,@body))

 ;; Need to use “progn”!
 (defmacro not-first (&rest body)
  `(progn ,@(cdr `,@body)))

 (macroexpand '(not-first x y z))
 ;; `,@body       ⇒ (x y z)
 ;; (cdr `,@body) ⇒ (y z)
 ;; `(progn ,@(cdr `,@body))
 ;;        ⇒ (progn y z)
#+END_SRC

  :Try_it_out:
  #+BEGIN_SRC emacs-lisp
  (first (insert "x") (insert "y") (message "z"))
    
  (not-first (insert "x") (insert "y") (message "z"))
#+END_SRC
  :End:

  #+end_parallel
  
  0. Certain problems are elegantly solved specific language constructs;
     e.g., list operations are generally best defined by pattern matching.
     # Likewise for any ADT.

  1. Macros let us /make/ the best way to solve a problem when our language does
     not give it to us.
     
     # --They can also be used to reduce repetitive visual noise.
     # Which is achievable by using higher-order operations.
     #
     # IMHO macros are best for creating new syntax.

  2.  Macro expansion happens before runtime, function execution, and so the
      arguments passed to a macro will contain raw source code.

      [[http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm][Backquotes]] let us use the comma to cause the actual variable /names/
      and /values/ to be used --e.g., ~x~ is a ‘meta-variable’ and its value, ~,x~,
      refers to a real variable or value.

      The ~&rest~ marker allows us to have multiple statements at the end of the macro:
      The macro expander provides all remaining expressions in the macro as a list,
      the contents of which may be inserted in place, not as a list, using the
      [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html][ ~,@~ splice comma]]  --we need to ensure there's a ~progn~.

       Use list elements in-place:
       #+latex: \vspace{-1em}
       | ~`(pre ,@(list s₀ ⋯ sₙ) post) ≈ `(pre s₀ ⋯ sₙ post)~ |
       #
       # This works:  `(pre ,@'(s0 ⋯ sn) post)
       #             ≈ '(pre s0 ⋯ sn post)
       #
       # Woah!
  
+ ~macroexpand~ takes /code/ and expands any macros in it. It's useful in debugging macros.
  The above ‘equations’ can be checked by running ~macroexpand~; \newline e.g.,
  ~(when c s₀ ⋯ sₙ) ≈ (if c (progn s₀ ⋯ sₙ) nil)~ holds since:

   #+BEGIN_SRC elisp
(macroexpand '(when c s₀ ⋯ sₙ)) ;; ⇒ (if c (progn s₀ ⋯ sₙ))
#+END_SRC
    
+ If ~var~ is an argument to a macro where ~,var~ occurs multiple times, then since
  arguments to macros are raw source code, each occurrence of ~,var~ is an execution of the
  code referenced by ~var~.

  \room
  Avoid such repeated execution by using a ~let~ to capture the result, call it ~res~, once
  and use the ~res~ in each use site.

  \room
  Now we've made use of the name ~res~ and our users cannot use that name correctly.
  Avoid such /unintended/ capture by using ~gensym~ to provide us with a globally unique
  name which is bound to a variable, say ~r~, then we bind the result of executing ~var~
  to the fresh name ~,r~.

  \room  
  Whence: ~`(⋯,var⋯,var⋯)~
    @@latex:\newline{\color{white}.}\hspace{2em}@@
    ~⇒ (let ((r (gensym))) `(let ((,r ,var)) ⋯,r⋯,r⋯))~.

  \room  
  Note that the name ~r~ is outside the backquote; it is part of code that is run
  at macro expansion time, not runtime. The value of the final ~let~ is then the backquoted
  matter, which makes /no/ reference to ~r~, but instead makes use of the name it
  refers to, ~,r~. Neato!

  \room
  Ex., remove repeated execution from ~(defmacro twice (var) `(list ,var ,var))~.
  :Try_it_out:
  #+BEGIN_SRC emacs-lisp
(defmacro twice (var)
  `(list ,var ,var))

(macroexpand '(twice x))

(twice 3)
(twice (progn (insert "\nwow") 3))

(defmacro duplicate (var)
  (let1 r (gensym)
    `(let1 ,r ,var
       (list ,r ,r)
    )
  )
)

(duplicate 3)
(duplicate (progn (insert "\nwow") 3))
#+END_SRC
  :End:

+ Test that you don't have accidentally variable capture by passing in an insert
   statement and see how many times insertions are made.

+ Macros that /intentionally/ use variable capture as a feature, rather than a bug,
  to provide names available in the macro body are called ‘anaphoric macros’.

  \room  
  E.g., ~(split list no yes)~ provides the names ~head, tail~ in the ~yes~ body
  to refer to the head and tail of the given ~list~, say via a ~let~, but not so in the
  ~no~ argument for when ~list~ is empty. Whence, elegant pattern matching on lists.

  \room Exercise: Define ~split~.
  :Try_it_out:
#+BEGIN_SRC emacs-lisp
(defmacro split (list no &rest yes)
  `(if ,list (let ((head (car ,list)) (tail (cdr ,list))) ,@yes) ,no)
)

;; Example use

(defun sum (xs) (split xs 0 (+ head (sum tail))))

(sum '(1 2 3 4 5)) ;; ⇒ 15
#+END_SRC
:End:

* COMMENT Macros                                                  :old_notes:
+ Sometimes we don't want eager evaluation; i.e., we do not want to
  recursively evaluate arguments before running a function.
+ /Macros/ let us manipulate a program's abstract syntax tree, usually
  by delaying some computations --easy since Elisp lets us treat code as data.

\room
~`(e₀ e₁ ⋯ eₖ)~ is known as a /quasi-quote/: It produces syntactic data like ~quote~
  but allows computations to occur --any expression prefixed with a comma as in ~,e₃~--
  thereby eagerly evaluating some and delaying evaluation of others.

#+BEGIN_SRC elisp
(defun my/lazy-or (this that)
  (if this t that))

(my/lazy-or (print "yup") (print "nope")) ;; evaluates & prints both clauses!
(my/lazy-or t (/ 2 0)) ;; second clause runs needlessly, causing an error.

;; Delay argument evaluation using defmacro
(defmacro my/lazy-or-2 (this that)
  `(if ,this t ,that))

(my/lazy-or-2 (print "yup") (print "nope")) ;; just "yup" ;-)
(my/lazy-or-2 t (/ 2 0)) ;; second clause not evaluated

;; What code is generated by our macro?
(macroexpand '(my/lazy-or-2 t (/ 2 0))) ;; ⇒ (if t t (/2 0))
#+END_SRC

We've added new syntax to Elisp!

\room
The above ‘equations’ can be checked by running ~macroexpand~; \newline e.g.,
~(when c s₀ ⋯ sₙ) ≈ (if c (progn s₀ ⋯ sₙ) nil)~ holds since

#+BEGIN_SRC elisp
(macroexpand '(when c s₀ ⋯ sₙ)) ;; ⇒ (if c (progn s₀ ⋯ sₙ))
#+END_SRC

Woah!

* spacing COMMENT newpage                                                    :ignore:
\newpage
* COMMENT Hooks
+ We can ‘hook’ methods to run at particular events.
+ Hooks are lists of functions that are, for example, run when a mode is initialised.

# Hooks are lists of functions that are called from Emacs Lisp in order to modify the behaviour of something. 
# For example, different modes have their own hooks so that you can add functions that will run when that mode is initialised.

E.g.,
let's add the ~go~ function to the list of functions when a buffer 
is initialised with org-mode.
#+BEGIN_SRC elisp
(describe-symbol 'org-mode-hook)

(defun go () (message-box "It worked!"))

  (add-hook 'org-mode-hook 'go)
≈ (add-hook 'org-mode-hook '(lambda () (message-box "It worked!")))
≈ (add-to-list 'org-mode-hook 'go)

;; Now execute: (revert-buffer) to observe “go” being executed.
;; Later remove this silly function from the list:
(remove-hook 'org-mode-hook 'go)
#+END_SRC

+ The ~'after-init-hook~ event will run functions after the rest of the init-file has finished loading.

* spacing vfill                                                     :ignore:
\vfill

* ~read~ and ~print~

‘Reading’ means parsing an expression in textual form and producing a lisp object.
E.g., this is a way to load a lisp file. ‘Printing’ a lisp object mean producing
a textual representation. These operations, in lisp, are mostly inverse.

\room
The ~read-from-string~ command works just like the ~read~ command, but 
lets us read a lisp object from a string instead of directly from the console.

#+BEGIN_SRC emacs-lisp
(defun sum-two ()
  (let (fst snd)
    (setq fst (read))
    (setq snd (read))
    (+ (eval fst) (eval snd))
  )
)

;; Run (sum-two) with inputs (+ 1 2) and (* 3 4)  ;-)
#+END_SRC
  
Lisp makes writing a REPL astonishingly easy: “Loop as follows:
Print the result of evaluating what is read at the prompt.”
#+BEGIN_SRC emacs-lisp
(loop (print (eval (read))))  ;; Beautiful ♥‿♥
#+END_SRC

 + ~loop~ merely loops forever.

 The ~print~ and ~read~ commands work on all kinds of data, such as lists of data
   structures. Hence, we must use quotes if we want to read a string rather than a
   symbol, for example.

\room   
A major problem with this REPL is that ~eval~ executes any, potentially malicious,
Lisp command entered by the user. Ideally one checks the read lisp object is
safe ---say, it is one of some allowable commands--- and only then evaluates it.
:A_safer_repl:
#+BEGIN_SRC emacs-lisp
(defun f () (message-box "f was called"))
(defun g () (message-box "g was called"))
(defun h () (message-box "h was called"))
(setq safe-commands '(f g h))

;; This reply can only execute: (f), (g), (h), quit
(catch 'quit
(loop
  (let ((sexp (read)))
    (when (equal sexp 'quit) (throw 'quit "byebye"))
    (if (member (car sexp) safe-commands)
        (eval sexp)
	'(I do not know that command)))))
#+END_SRC
:End:
 
* TODO COMMENT Format --land of lisp 
  
Format :: 223 discuss a and s, ~& for printing a new line if need be whence no ugly empty lines, 228 for ~t, 231 for printings lists. Format is a dsl, there's so much!
  
* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC elisp :results none
(with-temp-buffer
    (insert 
    "#+EXPORT_FILE_NAME: README.md
     #+HTML: <h1> ElispCheatSheet </h1>
     #+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     Quick reference to the core language of Emacs ---Editor MACroS.
     
     ( Much Emacs Lisp was utilised in making my blog
     https://alhassy.github.io )

     *The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*, 
     while below is an unruly html rendition.
 
     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     #+TOC: headlines 2
     #+INCLUDE: CheatSheet.org     
    ")
    ;; (set-visited-file-name "ReadIt2.md")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer

# Local Variables:
# eval: (org-babel-tangle)
# eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (org-babel-load-file "CheatSheet/CheatSheet.org")
# compile-command: (my-org-latex-export-to-pdf)
# End:
